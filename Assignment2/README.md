# Test - Assignment 2

[Assignment description](./assignment-02.pdf)

This assignment consists of sections 1-3 where section 2 should be written individually. The other two sections are written together.

The solution for sections 1 & 3 can be found in this document. The solutions for part two can for each member be found in the [PartTwo](./PartTwo) folder.

## Part 1 - Reflections

### 1.1 Computer Mouse
> _Identify the types of testing you would perform on a computer mouse, to make sure that it is of the highest quality._

```diff
- TODO
```

### 1.2 Catastrophic failure
> _Find a story where a software system defect had a bad outcome. Describe what happened. Can you identify a test that would have prevented it?_

```diff
- TODO
```

## Part 2 - Two katas
This part of the assignment was required to be completed individually. 

The solutions for each member can be found in the [PartTwo](/PartTwo) folder.

## Part 3 - Investigation

### 3.1 JUnit 5
> _Investigate JUnit 5 (Jupiter). Explain the following, and how they are useful._

`@Tag`
- Tag is an annotation that can be applied to both classes and methods to categorize them for the _discovery and execution_ part of the framework. This is useful for not only marking tests but also for filtering them for execution. You could configure JUnit to only run certain tests, [i.e. only tests marked with "acceptance"](https://junit.org/junit5/docs/current/user-guide/#running-tests-build-maven-filter-tags). 
More details can be found in the user guide, such as [this section](https://junit.org/junit5/docs/current/user-guide/#running-tests-tags).

@Tag supports [inheritance/extension for custom types](https://junit.org/junit5/docs/current/user-guide/#writing-tests-meta-annotations). 

**Example:**
```java
@Tag("fast")
@Tag("model")
class TaggingDemo {
    //...
}
```

```diff
- TODO, actual example from IDE and output window effects
```


`@Disabled`
- In JUnit 4 this was known as _@Ignore_. This is an annotation for both classes and methods which mark them to be skipped for execution.
This is useful for skipping tests that are not fixed now but will be in the future. If the test is no longer relevant it should be removed.

**Example:**
```java
@Disabled("Disabled until bug #99 has been fixed")
class DisabledClassDemo {
    //...
}
```

`@RepeatedTest`
- This annotation marks a test (that you would normally mark with _@Test_) as a test that should be run a number of times rather than only once. Each invocation of a repeated test behaves like the execution of a regular _@Test_ method.  
The annotation takes a parameter of a single number - the amount of repeats you want.
Optinally you can customize the output with the _name_ parameter. It supports the dynamic placeholders _{currentRepetition}_ and _{totalRepetitions}_ to distinguish between tests. ([Source](https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests))

**Example:**
```java
@RepeatedTest(10) //Run 10 times
void repeatedTest() {
    // ...
}
```

```diff
- TODO, actual example from IDE and console output + name parameter
```

`@BeforeEach`, `@AfterEach`
- This annotation marks a method that should be run before/after each _@Test_. It can be used to setup and tear down implementation specifics between tests. An example could be the instantiation of a mock collection that could have been "tampered" with by the test before.

`@BeforeAll`, `@AfterAll`
- This annotation marks a static-only method that should be run once, before/after any of the *@Test*s are run. This is useful for initialization and cleanup. An example could be testing with integrations where a one-time setup (and of course a cleanup) is needed.

`@DisplayName`
- Overwrites the custom displayName generated by the output. This is useful if you want more clarity than provided by the test method name, i.e. they follow a standard not as easily distinguishable as the displayName. [Use case examples](https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-names).

`@Nested`
- This annotation marks a progression or change in the current test class. The class may exist within another class or it can be used for grouping classes if there are multiple.
If you test multiple implementations of the same class within a file, this tag can be used to seperate them for clearer and better test reports.  
A good example is available [here](https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested) where the annotation is used in conjunction with classes to display state changes of an implementation.

`assumeFalse`, `assumeTrue`
- These methods are part of the junit.jupiter subset and are known as [Assumptions](https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions). They can be used to verify certain elements of the system before continuing with the test. It can also be used to run only certain parts of the test given certain assumptions. Examples available in link above.


### 3.2 Mocking frameworks
> _Investigate mocking frameworks for your preferred language. Choose at least two frameworks, and answer the questions._

For this comparison we chose [Mockito](https://site.mockito.org/) and [EasyMock](https://easymock.org/). We considered [JMockit](https://jmockit.github.io/changes.html) and [jMock](http://jmock.org/) but they have not seen any updates since 2019.

Mockito actually [has their own article on this comparison](https://github.com/mockito/mockito/wiki/Mockito-vs-EasyMock) which is worth a read. It is however from 2014 so some things may have changed. Worth of notice is the second sentence, which states that Mockito actually started off as a fork of EasyMock.

What are their similarities?
- Open-source
- For Java

What are their differences?
- Mockito is licensed under the MIT license, EasyMock under the Apache License.
- Mockito is from ~2007, EasyMock from 2001.

Which one would you prefer, if any, and why?
- Mockito due to its larger usebase. At a glance its API looks cleaner and easier to use and is hailed as the superior option.



_Honorable mention: [PowerMock](https://github.com/powermock/powermock) - the framework that allows you to unit test code normally regarded as untestable._


## Sources
- https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations
- https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4
- https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions
- https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#Java

### Unused sources that may be of interest
- https://dzone.com/articles/best-java-unit-testing-frameworks
- https://www.baeldung.com/mockito-vs-easymock-vs-jmockit
